KMP식 점핑 핵심은

틀린 부분이 생겼을 때.
여태까지 매칭한 문자열이 있다면,
그리고 해당문자열의 접두와 접미에 같은 부분이 있다면
접미 부분을 새로운 접미로 생각하여 애초에 맞은 부분으로 간주하고
패턴을 prefix=suffix인 부분의 길이만큼 뛰어넘고 비교한다

비교했는데 또 틀리면....
자른 부분의 접두와 접미를 또 구하고....
윗문단을 반복

했는데 결국 j가 0이라면
패턴의 시작지점으로 리셋이다. 이 때 비교하던 위치i는 리셋안된다
0일때 같으면 j도 같이가고, 1문단에서 하던일을 반복할 수 있을것이다

그런데 0일 때조차 같지 못한다면
그냥 i만 한 칸 for문으로 자연스럽게 넘어가게 될것이다

i = 4부터 비교를 하는 상황에서
              o            i(= 10)
CTCA(CTGCCT)GCCTAG
           = = = = ==  x
          (CTGCCT)AG (j = 6)
j - 1 = 5
table[5] = 2

i = 4, j = 0에서 시작해서 i 4~9와 j = 0~5 6개가 일치
i = 10, j = 6에서 G와 A로 불일치

j는 i를 검사할 때 몇개를 건너뛰고 검사할 것인지에 대한 표식이다
(6-1)까지 0~5를 뛰어넘었는것이 

CTCACTGC(CT/GCCTAG
	  (CT/GCCTAG





가장 최근까지 매칭되었던 원소의 시작부터의 LPS값은
어떻게 패턴문자의 개수만큼 이전의 원소들과 일치하는지
보장하는가

시작 지점 부터 j개의 원소들은 이미 매칭이 됨이 확인되었다
양끝!!!!
양끝에서 줄인다!!@




j는 시작위치에서
j = 0부터 시작했던(첫 시작이건, 중간에 리셋되었건) 위치부터의
문자열이 겹치는 수(혹은 위치)의 바로 뒤를 의미한다

즉 j = table[j-1]에서
j - 1은 여태까지 일치했었던 문자열의 개수이다
특정 시점부터 j개의 문자열이 일치한다

해당값은 '시작위치'에서 몇 개의 문자열이 접두/접미가 같으냐이다
